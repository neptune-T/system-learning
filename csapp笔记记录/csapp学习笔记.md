# csapp学习笔记

## hello world有多复杂

### 从c语言层面观察

hello 程序的生命周期是从一个高级 C 语言程序开始的，因为这种形式能够被人读懂。然而，为了在系统上运行 hello.c 程序，每条 C 语句都必须被其他程序转化为一系列的低级机器语言指令。然后这些指令按照一种称为可执行目标程序的格式打好包，并以二进制磁盘文件的形式存放起来。目标程序也称为可执行目标文件

在这里，GCC 编译器驱动程序读取源程序文件 hello.c，并把它翻译成一个可执行目标文件 hello。这个翻译过程可分为四个阶段完成，如图 1-3 所示。执行这四个阶段的程序（预处理器、编译器、汇编器和链接器）一起构成了编译系统（compilation system）。

![img](https://1087580735-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHt_spaxGgCbp2POnfq%2F-MHzZfEIY91yIzOD0Rce%2F-MHzZpZI-gs8CNcwHIyv%2F01-03%20compilation%20systems.png?alt=media&token=91ca688e-1cfc-4ec6-8b99-d52e672bbac7)

我们可以一步一步来看看干了什么

```main.c
#include <stdio.h>
int main()
{
    printf("hello, world\n");
    return 0;
}
```

预处理阶段:预处理器（cpp）根据以字符 # 开头的命令，修改原始的 C 程序。比如 hello.c 中第 1 行的#include <stdio.h>命令告诉预处理器读取系统头文件 stdio.h 的内容，并把它直接插入程序文本中。结果就得到了另一个 C 程序，通常是以 .i 作为文件扩展名。 
编译阶段。编译器（ccl）将文本文件 hello.i 翻译成文本文件 hello.s，它包含一个汇编语言程序



```
gcc hello.c
```

在使用这个命令的时候会得到a.out文件，这里全称是assembler output

得到的这个文件是什么？我们不妨使用`file`文件去查看

结果是

```
a.out: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=d37656d3b60f68f116d718b9a4b062bf6ee82164, for GNU/Linux 3.2.0, not stripped
```

是一个ELF文件，什么是ELF呢？executable linkable format，可执行可链接的文件

```
./a.out输出
```

如果想去了解内部二进制文件是什么,使用vim a.out得到的结果一堆乱码和一小部分的有用信息

我们可以使用`objdump`来查看文件

```
objdump -d a.out | less
```

```
    1104:       80 3d 05 2f 00 00 00    cmpb   $0x0,0x2f05(%rip)        # 4010 <__TMC_END__>
    110b:       75 2b                   jne    1138 <__do_global_dtors_aux+0x38>
    110d:       55                      push   %rbp
    110e:       48 83 3d e2 2e 00 00    cmpq   $0x0,0x2ee2(%rip)        # 3ff8 <__cxa_finalize@GLIBC_2.2.5>
    1115:       00
    1116:       48 89 e5                mov    %rsp,%rbp
    1119:       74 0c                   je     1127 <__do_global_dtors_aux+0x27>
    111b:       48 8b 3d e6 2e 00 00    mov    0x2ee6(%rip),%rdi        # 4008 <__dso_handle>
    1122:       e8 19 ff ff ff          call   1040 <__cxa_finalize@plt>
    1127:       e8 64 ff ff ff          call   1090 <deregister_tm_clones>
    112c:       c6 05 dd 2e 00 00 01    movb   $0x1,0x2edd(%rip)        # 4010 <__TMC_END__>
    1133:       5d                      pop    %rbp
    1134:       c3                      ret
    1135:       0f 1f 00                nopl   (%rax)
    1138:       c3                      ret
    1139:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)

0000000000001140 <frame_dummy>:
    1140:       f3 0f 1e fa             endbr64
    1144:       e9 77 ff ff ff          jmp    10c0 <register_tm_clones>

0000000000001149 <main>:
    1149:       f3 0f 1e fa             endbr64
    114d:       55                      push   %rbp
    114e:       48 89 e5                mov    %rsp,%rbp
    1151:       48 8d 05 ac 0e 00 00    lea    0xeac(%rip),%rax        # 2004 <_IO_stdin_used+0x4>
    1158:       48 89 c7                mov    %rax,%rdi
    115b:       e8 f0 fe ff ff          call   1050 <puts@plt>
    1160:       b8 00 00 00 00          mov    $0x0,%eax
    1165:       5d                      pop    %rbp
    1166:       c3                      ret

Disassembly of section .fini:

0000000000001168 <_fini>:
    1168:       f3 0f 1e fa             endbr64
    116c:       48 83 ec 08             sub    $0x8,%rsp
    1170:       48 83 c4 08             add    $0x8,%rsp
    1174:       c3                      ret
```

我们可以清楚看见二进制文件内容，并为此感到惊叹：hello.c一个非常简单的代码为什么会有这么多的的东西

这时候的编译没有静态链接所有的库

倘若我要是用

```
gcc hello.c -static
objdump -d a.out | less
```

可以更加明显的感觉到文件之大



直接使用gcc，上来就直接生成a.out文件，中间过程怎么看见？

**第一步**

hello.c经过预处理器（cpp）变成的hello.i文件长什么样子？

```
gcc -E hello.c -o hello.i
```

这一步处理源代码中的预处理指令，如宏定义和头文件包含

我们可以使用`cat hello.i`查看文件

**第二步**

hello.i文件经过编译器(ccl)变成的hello.s是什么，干了什么，我可不可以看见发生了什么？

```
gcc -S hello.i -o hello.s
```

```
cat hello.s
```

可以很清楚看见转换汇编代码

**第三部分**

编译器是什么（as）hello.o是什么？

说白了就是将汇编代码转换为机器代码，生成目标文件

```
gcc -c hello.s -o hello.o
cat hello.o
```

这时候为什么用cat打开文件是这个样子？

```
 File: hello.o   <BINARY>
```

已经是二进制文件了，cat对于二进制文件看不了的

可以使用

```
objdump -d hello.o
```

会发现

```
hello.o：     文件格式 elf64-x86-64


Disassembly of section .text:

0000000000000000 <main>:
   0:	f3 0f 1e fa          	endbr64
   4:	55                   	push   %rbp
   5:	48 89 e5             	mov    %rsp,%rbp
   8:	48 8d 05 00 00 00 00 	lea    0x0(%rip),%rax        # f <main+0xf>
   f:	48 89 c7             	mov    %rax,%rdi
  12:	e8 00 00 00 00       	call   17 <main+0x17>
  17:	b8 00 00 00 00       	mov    $0x0,%eax
  1c:	5d                   	pop    %rbp
  1d:	c3                   	ret
```

**最后**

最后的链接是什么？什么是链接？

```
gcc hello.o -o hello
```

我们使用ls不难发现多了一个文件是hello，这个和最初的a.out一样吗？

可以眼睛查看区别

```
objdump -d a.out | less
objdump -d hello | less
```

如果objdump文件太大，可以使用重定向文件之后使用git diff判断差别

```
objdump -d a.out > a_out_dump.txt
objdump -d hello > hello_dump.txt
diff a_out_dump.txt hello_dump.txt
```

差别在于

- `2c2`: 这表示第二行在两个文件中有所改变。`2c2` 是一个简短的摘要，表明第二行在两个文件中被“更改”（change）了。
- `< a.out： 文件格式 elf64-x86-64`: 这一行显示在第一个文件（在这种情况下是 `a.out` 的 `objdump` 输出）中的内容。
- `---`: 这是分隔线，用来区分两个文件的内容。
- `> hello： 文件格式 elf64-x86-64`: 这一行显示在第二个文件（在这种情况下是 `hello` 的 `objdump` 输出）中的内容。

从这个输出可以看出，两个文件的不同之处仅在于它们的名称。第一个文件名是 `a.out`，而第二个文件名是 `hello`。除了文件名，这一行的其余部分（即文件格式 `elf64-x86-64`）在两个文件中是相同的。

```
2c2
< a.out：     文件格式 elf64-x86-64
---
> hello：     文件格式 elf64-x86-64

```

可见我们经历一个完整的过程去了解c语言中的hello world



### 从计算机硬件视角观察

 hello 程序时发生了什么，我们需要了解一个典型系统的硬件组织

- **总线**：  贯穿整个系统的是一组电子管道，称作总线，它携带信息字节并负责在各个部件间传递。通常总线被设计成传送定长的字节块，也就是字（word）。字中的字节数（即字长）是一个基本的系统参数，各个系统中都不尽相同。现在的大多数机器字长要么是 4 个字节（32 位），要么是 8 个字节（64 位）。本书中，我们不对字长做任何固定的假设。相反，我们将在需要明确定义的上下文中具体说明一个“字”是多大。 

- **I/O设备：**  I/O（输入/输出）设备是系统与外部世界的联系通道。我们的示例系统包括四个 I/O 设备∶作为用户输入的键盘和鼠标，作为用户输出的显示器，以及用于长期存储数据和程序的磁盘驱动器（简单地说就是磁盘）。最开始，可执行程序 hello 就存放在磁盘上。

  每个 I/O 设备都通过一个控制器或适配器与 I/O 总线相连。控制器和适配器之间的区别主要在于它们的封装方式。控制器是 I/O 设备本身或者系统的主印制电路板（通常称作主板）上的芯片组。而适配器则是一块插在主板插槽上的卡。无论如何，它们的功能都是在 I/O 总线和 I/O 设备之间传递信息。

- **主存：**主存是一个临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。从物理上来说，主存是由一组动态随机存取存储器（DRAM）芯片组成的。从逻辑上来说，存储器是一个线性的字节数组，每个字节都有其唯一的地址（数组索引），这些地址是从零开始的。一般来说，组成程序的每条机器指令都由不同数量的字节构成。与 C 程序变量相对应的数据项的大小是根据类型变化的。比如，在运行 Linux 的 x86-64 机器上，short 类型的数据需要 2 个字节，int 和 float 类型需要 4 个字节，而 long 和 double 类型需要 8 个字节。

- **CPU：**中央处理单元（CPU），简称处理器，是解释（或执行）存储在主存中指令的引擎。处理器的核心是一个大小为一个字的存储设备（或寄存器），称为程序计数器（PC）。在任何时刻，PC 都指向主存中的某条机器语言指令（即含有该条指令的地址）。

  从系统通电开始，直到系统断电，处理器一直在不断地执行程序计数器指向的指令，再更新程序计数器，使其指向下一条指令。处理器看上去是按照一个非常简单的指令执行模型来操作的，这个模型是由指令集架构决定的。在这个模型中，指令按照严格的顺序执行，而执行一条指令包含执行一系列的步骤。处理器从程序计数器指向的内存处读取指令，解释指令中的位，执行该指令指示的简单操作，然后更新 PC，使其指向下一条指令，而这条指令并不一定和在内存中刚刚执行的指令相邻。
  这样的简单操作并不多，它们围绕着主存、寄存器文件（register file）和算术/逻辑单元（ALU）进行。寄存器文件是一个小的存储设备，由一些单个字长的寄存器组成，每个寄存器都有唯一的名字。ALU 计算新的数据和地址值。下面是一些简单操作的例子，CPU 在指令的要求下可能会执行这些操作。

  加载：从主存复制一个字节或者一个字到寄存器，以覆盖寄存器原来的内容。
  存储：从寄存器复制一个字节或者一个字到主存的某个位置，以覆盖这个位置上原 来的内容。 
  操作：把两个寄存器的内容复制到 ALU，ALU 对这两个字做算术运算，并将结果存放到一个寄存器中，以覆盖该寄存器中原来的内容。 
  跳转：从指令本身中抽取一个字，并将这个字复制到程序计数器（PC）中，以覆盖 PC 中原来的值。

   处理器看上去是它的指令集架构的简单实现，但是实际上现代处理器使用了非常复杂的机制来加速程序的执行。因此，我们将处理器的指令集架构和处理器的微体系结构区分开来：指令集架构描述的是每条机器代码指令的效果；而微体系结构描述的是处理器实际上是如何实现的。在第 3 章研究机器代码时，我们考虑的是机器的指令集架构所提供的抽象性。



当我们输入./hello，shell程序将字符逐一读取寄存器，放入内存，然后 shell 执行一系列指令来加载可执行的 hello 文件，这些指令将 hello 目标文件中的代码和数据从磁盘复制到主存。数据包括最终会被输出的字符串 “hello, world\n”。

![img](https://1087580735-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHt_spaxGgCbp2POnfq%2F-MHzbjGHhw9P3BFyZTKk%2F-MHzeim3VxH0O0hbd4Uh%2F01-05%20read%20hello%20from%20keyboard.png?alt=media&token=5956c888-1728-418c-8d21-83432d24ce77)

亦或者只用DMA来输出文件数据可以不通过处理器而直接从磁盘到达主存

![img](https://1087580735-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHt_spaxGgCbp2POnfq%2F-MHzfLHp5XFUFTsUJAKx%2F-MHzfN_gwQJSG2YnC5Gk%2F01-06%20%E4%BB%8E%E7%A3%81%E7%9B%98%E5%8A%A0%E8%BD%BD%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E5%88%B0%E4%B8%BB%E5%AD%98.png?alt=media&token=9a49507e-f20d-4af8-b277-bebf57cc597f)

一旦目标文件 hello 中的代码和数据被加载到主存，处理器就开始执行 hello 程序的 main 程序中的机器语言指令。这些指令将 “hello, world\n” 字符串中的字节从主存复制到寄存器文件，再从寄存器文件中复制到显示设备，最终显示在屏幕上

![img](https://1087580735-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHt_spaxGgCbp2POnfq%2F-MHzfVZwd5iIwJfDkOPj%2F-MHzffvOB90toXVTON5G%2F01-07%20%E5%B0%86%E8%BE%93%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BB%8E%E5%AD%98%E5%82%A8%E5%99%A8%E5%86%99%E5%88%B0%E6%98%BE%E7%A4%BA%E5%99%A8.png?alt=media&token=d0480c36-9640-4159-bc71-8f5db262a6ba)



## 程序的机械级表示



### 什么是ISA（Instruction Set Architecture）？

ISA，即指令集架构，是计算机架构的一个组成部分，它定义了处理器支持的指令集（即可以执行的所有操作），以及指令的格式、字节序、寄存器、地址模式、数据类型等。简而言之，ISA是软件和硬件之间的接口，它描述了软件如何控制硬件。举例来说，x86、ARM、MIPS都是不同类型的ISA。

**ISA的职责和目的**

ISA是软件和硬件之间的接口，它的主要职责包括：

- 定义指令集：ISA指定了处理器能够理解和执行的所有指令，包括算术、数据传输、控制等操作。

- 规定指令的格式和编码：它确定了如何用二进制代码表示各种指令。

- 确定寄存器和内存模型：ISA定义了处理器内部的寄存器组织以及如何与内存交互。

- 指定数据类型和操作模式：包括支持的数据类型（如整数、浮点数等）和操作模式（如用户模式和内核模式等）。



### 什么是计算机架构？

计算机架构通常指的是计算机系统的设计和组织，它包括ISA以及其他方面，如微架构（实现ISA的具体硬件细节）、系统架构（包括内存组织、I/O系统等）、并行架构等。计算机架构不仅涉及指令的集合和格式，还包括实现这些指令的硬件设计。

计算机架构包括了ISA（Instruction Set Architecture，指令集架构）以外的多个方面，这些方面是ISA不涵盖的，但对于整个计算机系统的设计和性能至关重要。以下是计算机架构包含而ISA通常不包含的一些重要组成部分：

**微架构（Microarchitecture）：**

微架构指的是实现特定ISA的具体方式。它涉及处理器内部的具体实现细节，如流水线的设计、缓存架构、执行单元、分支预测机制等。
不同的微架构可以实现相同的ISA，这意味着不同的处理器可能在执行同一套指令集时表现出不同的性能特点。

**系统架构：**

包括整个计算机系统的设计，如内存组织、I/O系统、总线结构、中断和异常处理机制等。
系统架构设计直接影响整个计算机系统的性能和效率。

**并行和并发架构：**

如多核处理器设计、超线程技术、向量处理和并行计算等。
这些设计用于提高系统处理大规模数据或多任务的能力。

**电源管理和散热设计：**

包括处理器功耗管理和散热解决方案，对于提高能效和保持系统稳定运行非常重要。

**安全特性：**

包括硬件级别的安全功能，如安全启动、加密加速器、硬件隔离等。

**容错和可靠性设计：**

如纠错码（ECC）内存、硬件故障检测和恢复机制。

**互连和通信：**

涉及不同计算机组件之间的数据交换方式，例如使用何种总线、网络连接等。
计算机架构的设计考虑了这些方面来确保整个系统的高效、可靠和安全运行，而ISA主要定义了软件和硬件之间的接口。这两者的结合决定了计算机系统的整体性能和功能。



### 什么是汇编语言

1. **定义**：汇编语言是一种低级编程语言，用于编写与特定ISA直接对应的指令。它提供了一种比机器码（二进制代码）更易于理解和编写的方式来表达指令。
2. **软件层面**：汇编语言是人类可读的表示形式，它使用助记符（如`MOV`、`ADD`等）来表示机器指令。每种ISA通常都有与之对应的汇编语言。
3. **ISA的直接反映**：汇编语言的每条指令直接对应于ISA中的一条机器指令。因此，不同的ISA将有不同的汇编语言。



isa和汇编语言的区别：

- **ISA是基础**：ISA是硬件层面的定义，是构建汇编语言的基础。汇编语言是ISA的直接表现，提供了编程接口。
- **不同层次的抽象**：ISA是更接近硬件的抽象，而汇编语言则是更接近程序员的抽象。
- **不同的目的**：ISA的设计目的是为了定义处理器的功能和行为，而汇编语言的目的是为了让程序员能够以更容易理解的方式编写接近硬件的代码。

